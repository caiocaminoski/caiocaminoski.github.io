<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>Street gender equality</title>
    <link rel="icon" type="image/x-icon" href="images/favicon.svg">
    <style>
        /* loader */
        #loader-overlay {
            position: fixed;
            width: 100%;
            height: 100%;
            background-color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            z-index: 1000;
            opacity: 1; 
            visibility: visible; 
        }

        .loader {
            display: flex;
            justify-content: space-around;
            align-items: center;
            width: 100px;
        }

        .ball {
            width: 20px;
            height: 20px;
            background-color: #27A8D8;
            border-radius: 50%;
            animation: bounce 3s infinite;
        }

        .ball:nth-child(2) {
            animation-delay: 0.3s;
        }

        .ball:nth-child(3) {
            animation-delay: 0.6s;
        }

        @keyframes bounce {
            0%, 20%, 100% {
                transform: translateY(0);
                background-color: #D85727;
            }
            50%, 70% {
                transform: translateY(-50px);
                background-color: #27A8D8;
            }
        }

        /* language containers */
        .lang-container {
            display: none;
        }

        .lang-container.active {
            display: block;
        }

        /* context menu */
        #context-menu {
            display: none;
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
            z-index: 10000;
        }
        #context-menu ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }
        #context-menu ul li {
            padding: 8px 12px;
            cursor: pointer;
        }
        #context-menu ul li:hover {
            background-color: #f0f0f0;
        }

        /* Popup container for form */
        #popupContainer {
            display: none;
            position: fixed;
            top: 10%;
            left: 10%;
            width: 80%;
            height: 80%;
            background: white;
            border: 1px solid #ccc;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            z-index: 1000;
        }
        #hideForm {
            display: none;
            position: fixed;
            top: 5%;
            left: 80%;  
            z-index: 1001;
            width: 10%;
            height: 36px;
            border: none;
            background-color: transparent;
            text-align: right;
            padding-right: 10px;
            color:white
        }
        #popupContainer iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        #popupOverlay {
            display: none; /* Initially hidden */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }

    </style>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/css/bootstrap.min.css" integrity="sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu" crossorigin="anonymous">
</head>
<body>

    <div id="loader-overlay">
        <div class="loader">
            <div class="ball"></div>
            <div class="ball"></div>
            <div class="ball"></div>
        </div>
    </div>

    <div id="context-menu">
        <ul>
            <li id="menu-item-1">Corrigir categoria ✎</li>
            <!-- <li id="menu-item-2">Test 2</li> -->
        </ul>
    </div>
    
    <div id="popupOverlay" onclick="MyGlobalFunctions.hidePopup()"></div>
    <button id="hideForm" onclick="MyGlobalFunctions.hidePopup()">✖</button>
    <div id="popupContainer">
        <iframe id="popupIframe" src=""></iframe>
    </div>

    <div id="en" class="lang-container active" lang="en">
        <h2 id="title-en" class="hidden">Analyzing gender equality in the streets of <span id="city-en"></span> - Brazil</h2>
        <p id="description-en" class="hidden"> From <span id="total-street-names-en"></span> street names analyzed, <span id="total-streets-people-en"></span> were classified as being after a <span id="women-text-en">woman</span> or a <span id="men-text-en">man</span>. Out of which:</p>
    </div>

    <div id="pt" class="lang-container" lang="pt">
        <h2 id="title-pt" class="hidden">Analisando igualdade de gênero nas ruas de <span id="city-pt"></span></h2>
        <p id="description-pt" class="hidden"> Entre os <span id="total-street-names-pt"></span> nomes de ruas analisados, <span id="total-streets-people-pt"></span> foram classificados como pertencendo a <span id="women-text-pt">mulheres</span> ou <span id="men-text-pt">homens</span>. Entre estes:</p>
    </div>

    <div id="container" class="hidden"></div>
    
</body>
<style>

    body {
        margin: 0 0 0 0;
        background: white;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        color: rgb(43, 43, 43);
    }

    .hidden {
        display: none;
    }

    svg {
        margin: 0 0 0 0;
        background: white;
    }

    path {
        transition: stroke 0.3s;
        cursor: pointer;
    }

    .overlay {
        opacity: 0;
    }

    .footer {
        color: #00000080;
        font-size: 1em;
        padding-right: 20px;
        width: 100%; 
        height: 100%;
        overflow: hidden;
        display: flex;
        flex-direction: column-reverse;
    }
    
    .footer span {
        display: block;
        white-space: normal; /* Allows text wrapping */
        word-break: break-word; 
    }

    .info {
        color: gray;
        font-size: small;
    }

    
    h1, h2, h3, h4, h5, p {
        margin-top: 12px; 
        margin-bottom: 12px;
        margin-left: 30px;
        margin-right: 30px;
    }

    h1, h2, h3, h4, h5 {
        font-size: 26px;
    }

    .kpi {
        cursor: pointer;
    }

    /* Small devices (tablets, etc.) */
    @media (min-width: 992px) { 

        p { 
            font-size: 1.2em;
        }

     }

</style>
<script type="module">
// import * as d3 from "https://cdn.skypack.dev/d3@7"
import { select, selectAll } from "https://cdn.skypack.dev/d3-selection@3";
import { csvParse } from "https://cdn.skypack.dev/d3-dsv@3";
import { scaleLinear, scaleSqrt } from "https://cdn.skypack.dev/d3-scale@4";
import { zoom, zoomIdentity } from "https://cdn.skypack.dev/d3-zoom@3";
import { transition } from "https://cdn.skypack.dev/d3-transition@3";
import { format, formatDefaultLocale, formatLocale } from "https://cdn.skypack.dev/d3-format@3";
import {interpolate} from "https://cdn.skypack.dev/d3-interpolate@3";
import { easeCubic, easeLinear, easeCubicOut} from "https://cdn.skypack.dev/d3-ease@3";
import { csv } from "https://cdn.skypack.dev/d3-fetch@3";
import { max } from "https://cdn.jsdelivr.net/npm/d3-array@3/+esm";

const city = getCity() ?? 'curitiba' // if no city is declared, it falls back to Curitiba

var paramForm;

// Function to import script variables 
function loadVariables(varPath) {
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = varPath;
        script.onload = resolve;
        script.onerror = () => reject(new Error(`Failed to load script: ${varPath}`));
        document.head.append(script);
    });
}

// function to import data
async function loadData(dataPath) {
    try {
        const response = await fetch(dataPath);
        if (!response.ok) {
        throw new Error(`Network response was not ok: ${response.statusText}`);
        }
        const csvText = await response.text();

        // Parse CSV data using d3-dsv
        const data_input = csvParse(csvText);

        const data = data_input.map((d, i)=>{
            return {
                id: i,
                name: d.name,
                path_data: d.path_data,
                gender: d.gender
            }
        })
        
        return data;

    } catch (error) {    
        hideLoader()
        console.error('Error fetching or parsing the CSV file:', error);
    }
}

// event listner to hide loader
window.addEventListener('load', function() {
    const overlay = document.getElementById('overlay');
    const content = document.getElementById('content');
    
    overlay.style.opacity = '0';
    overlay.style.visibility = 'hidden';

    setTimeout(() => {
        overlay.style.display = 'none';
        content.style.display = 'block';
    }, 200); // Match this duration with the CSS transition duration
});

function createViz(data) {
    
    var device;
    var chartLabelSize;
    var kpiTextSize;
    var kpiUnderlineSize;
    var fName;
    var mName;
    var textFooterCorrectStPT;

    var isDarkMode = detectDarkMode();

    if (language === 'pt') {
        fName = 'MULHERES'
        mName = 'HOMENS'
    } else {
        fName = 'WOMEN'
        mName = 'MEN'
    }

    // ***** variables for small devices
    if ( window.innerWidth < 992 ) {
        device = 'mobile';
        var margin = {top:84, right: 0, bottom: 60, left: 0},
        width = window.innerWidth - margin.left - margin.right - 30,
        height = window.innerHeight - margin.top - margin.bottom - (180);

        const chartXPosition = window.innerWidth / 3

        var fChart = {x: chartXPosition, y: margin.top/3 * 2};
        var mChart = {x: chartXPosition * 2, y:  margin.top/3 * 2};

        var chartRadius = margin.top * 0.4

        chartLabelSize = 14;
        kpiTextSize = 30;
        kpiUnderlineSize = 80;
        
        textFooterCorrectStPT = 'Encontrou um erro? Selecione e segure a rua para me avisar ✎'

    // ***** variables for larger devices
    } else {

        device = 'desktop';

        var margin = {top:0, right: 0, bottom: 20, left: 350},
        width = window.innerWidth - margin.left - margin.right - 30,
        height = window.innerHeight - margin.top - margin.bottom - (98);

        const chartYPosition = window.innerHeight / 7

        var fChart = {x: margin.left/2, y: chartYPosition * 2};
        var mChart = {x: margin.left/2, y: chartYPosition * 4};

        var chartRadius = ((height/2 < margin.left) ? height/2 : margin.left) * 0.4  // desktop with small height will use half of it instead of the margin to calculate ratius so they are less likely to overlap

        chartLabelSize = 20;
        kpiTextSize = 42;
        kpiUnderlineSize = 100;

        textFooterCorrectStPT = 'Encontrou um erro? Clique direito na rua para me avisar ✎'
    }

    const compensationX = (device == 'desktop')? compensationXDesktop : 0;
    const compensationY = (device == 'desktop')? 0 : compensationYMobile;


    var cPathM = '#27A8D8',
        cPathF = '#D85727',
        cPathO = 'gray';

    const ALL_Names = data.filter(function(d){ return d.name})

    // filtering data
    const M = data.filter(function(d){ return d.gender == "M" })
    const F = data.filter(function(d){ return d.gender == "F" })
    const O = data.filter(function(d){ return d.gender != "F"  && d.gender != "M"})

    // defining main counts that will be plot in the charts
    const M_count = Object.keys(M).length
    const F_count = Object.keys(F).length
    const P_count = M_count + F_count
    const O_count = Object.keys(O).length

    const numFormat = format(".0f")

    // adding variables to title and description
    select(`#total-street-names-${language}`).text(numFormat(Object.keys(ALL_Names).length));
    select(`#total-streets-people-${language}`).text(numFormat(P_count));
    select(`#city-${language}`).text(cityName);

    // Reveal the title and desc after updating the text
    select(`#title-${language}`).classed("hidden", false);
    select(`#description-${language}`).classed("hidden", false);

    // creating svg
    const svg = select('#container').append('svg')
        .attr('height', height + margin.top + margin.bottom)
        .attr('width', width + margin.left + margin.right)            
        .on("contextmenu", function (event) {event.preventDefault();})

    // adjust color of text in description
    select(`#men-text-${language}`)
        .attr('gender', fName)
        .style('color', cPathM)

    select(`#women-text-${language}`)
        .attr('gender', mName)
        .style('color', cPathF)

    const lonRange = maxLon - minLon;
    const latRange = maxLat - minLat;
    
    // Calculate aspect ratio
    const aspectRatio = width / height;

    // Calculate the map's aspect ratio
    const mapAspectRatio = lonRange / latRange;

    let scaleX, scaleY;


    const fractionLonRang = lonRange * scalingFactor;
    const fractionLatRang = latRange * scalingFactor;

    if (mapAspectRatio > aspectRatio) {
        // The map is wider than the container
        scaleX = scaleLinear()
        .domain([minLon, maxLon - fractionLonRang])
        .range([margin.left, margin.left + width]);

        const adjustedHeight = width / mapAspectRatio;
        const offsetY = (height - adjustedHeight) / 2;

        scaleY = scaleLinear()
        .domain([minLat + fractionLatRang, maxLat])
        .range([margin.top + adjustedHeight + offsetY, margin.top + offsetY]);
    } else {

        const adjustedWidth = height * mapAspectRatio;
        const offsetXTotal = (width - adjustedWidth);

        var offsetXLeft = offsetXTotal / 2;
        var offsetXRight = offsetXTotal / 2;

        scaleX = scaleLinear()
        .domain([minLon, maxLon - fractionLonRang])
        // .range([margin.left, margin.left + adjustedWidth]); // map oriented to the left
        // .range([margin.left + offsetXLeft, margin.left + adjustedWidth + offsetXRight]);  // map centered
        .range([margin.left + ((device == 'mobile') ? offsetXLeft : 0), margin.left + adjustedWidth + ((device == 'mobile') ? offsetXRight : 0)]);  // if it is a mobile it is adjusted to the center, otherwise it stays oriented right
    
        // The map is taller than the container
        scaleY = scaleLinear()
        .domain([minLat + fractionLatRang, maxLat])
        .range([margin.top + height, margin.top]);

    }

    // Function to transform path data
    function transformPathData(pathData) {
        return pathData.replace(/([ML])\s*([-\d.]+),([-\d.]+)/g, function(match, command, lon, lat) {
            const transformedLon = scaleX(+lon)
            const transformedLat = scaleY(+lat)
            return `${command} ${transformedLon},${transformedLat}`
        });
    }

    // highlight
    // funciton to handle highlight
    function handleMouseEnter() {
        const overlay = svg.select('.overlay');

        // Move the overlay to the end of the parent
        overlay.node().parentNode.appendChild(overlay.node());

        overlay.transition().duration(150).style('opacity', 1);

        // create copy of the hovered item on top of the overlay
        svg.select('.map').append('path')
            .attr('id', 'hovered')
            .attr('d', select(this).attr('d'))
            .attr('stroke', select(this).attr('stroke'))
            .style('fill', 'none')
            .style('pointer-events', 'none')

    }

    // funciton to handle highlight
    function handleMouseOut() {
        const overlay = svg.select('.overlay');

        overlay.transition().duration(150).style('opacity', 0);

        // remove copy of the hovered item from the top of the overlay
        svg.select('#hovered').remove()        
    }

    // Tooltip
    // create a tooltip
    var Tooltip = select("#container")
        .append("div")
        .style("opacity", 0)
        .attr("class", "tooltip")
        .style("background-color", "white")
        .style("border", "solid")
        .style("border-width", "1px")
        .style("border-color", "lightgray")
        .style("border-radius", "2px")
        .style("padding", "5px")
        .style('pointer-events', 'none')

    // Three function that change the tooltip when user hover / move / leave a cell
    var mouseover = function(e, d) {
        if (d.name) {
            Tooltip
            .style("opacity", 1)
        }
    }
    var mousemove = function(e, d) {
        Tooltip
        .html(d.name)
        .style("left", (e.pageX + 30) + "px")
        .style("top", (e.pageY) + "px")
    }
    var mouseleave = function(e, d) {
        if (d.name) {
            Tooltip
            .style("opacity", 0)
        }
    }

    function highlightGender() {

        if (select(this).attr('gender') == fName ) {
            svg.selectAll('path.pathO').transition().duration(350).style('opacity', 0.2);
            svg.selectAll('path.pathM').transition().duration(350).style('opacity', 0.2);

        } else if (select(this).attr('gender') == mName ) {
            svg.selectAll('path.pathO').transition().duration(350).style('opacity', 0.2);
            svg.selectAll('path.pathF').transition().duration(350).style('opacity', 0.2);

        }
    }

    function unHighlightGender() {

        if (select(this).attr('gender') == fName ) {
            svg.selectAll('path.pathO').transition().duration(350).style('opacity', 1);
            svg.selectAll('path.pathM').transition().duration(350).style('opacity', 1);

        } else if (select(this).attr('gender') == mName ) {
            svg.selectAll('path.pathO').transition().duration(350).style('opacity', 1);
            svg.selectAll('path.pathF').transition().duration(350).style('opacity', 1);

        }
    }

    // Three function that change the tooltip when user hover / move / leave a cell
    var mouseoverKPI = function(e, d) {
        Tooltip.transition().duration(300).ease(easeCubic)
            .style("opacity", 0.9)
    }

    var mousemoveKPI = function(e, d) {
        Tooltip
        .html((language === 'pt') ? 
            `<b>${d[2]}</b> ruas foram classificadas como referentes a <b><span style="color: ${d[3]}">${d[5].toLowerCase()}</span></b> (${percFormatDec(d[2]/P_count)}) ${(device == 'desktop') ? '<br><small>(Clique para esconder essa mensagem)</small>' : ''} `
            :`<b>${d[2]}</b> streets were classified as named after <b><span style="color: ${d[3]}">${d[5].toLowerCase()}</span></b> (${percFormatDec(d[2]/P_count)}) ${(device == 'desktop') ? '<br><small>(clike here to hide this message)</small>' : ''} `)
        .style("left", (e.pageX) + "px")
        .style("top", (e.pageY + 30) + "px")
    }
    var mouseleaveKPI = function(e, d) {
        Tooltip.transition().duration(300).ease(easeCubic)
            .style("opacity", 0)
    }

    var mouseclickKPI = function(e, d) {
        Tooltip.transition().duration(300).ease(easeCubic)
            .style("opacity", 0)
    }

    var openContextMenu = function() {
        const streetData = event.srcElement.__data__

        const streetName = (streetData.name) ? streetData.name : '**** SEM NOME ****';

        paramForm = `form.html?streetName=${streetName}&streetId=${streetData.id}&cityName=${cityName}&currentCategory=${streetData.gender}`

        document.getElementById('menu-item-1').innerHTML = `Corrigir ${streetName} ✎`

        contextMenu.style("display", "block")
            .style("left", `${event.pageX}px`)
            .style("top", `${event.pageY}px`);
    }
    
    // we initialize the map so it is rendered below kpis
    const map = svg.append('g').classed('map', true)

    // append overlay that is used for highlight
    svg.select('.map').append('rect')
        .classed('overlay', true)
        .attr('x', margin.left)
        .attr('y', margin.top)
        .attr('height', height / (1 - scalingFactor))
        .attr('width', width / (1 - scalingFactor))
        .attr('fill', (isDarkMode === 0) ? 'rgba(255, 255, 255, 0.6)' : 'rgba(0, 0, 0, 0.6)')
        .style('pointer-events', 'none')

    // define frame for map (it needs to come before KPIs so they sit on top of it)
    // Define outer and inner rectangles for the frame path
    const outerRect = `M 0,0 H ${width + margin.left + margin.right} V ${height + margin.top + margin.bottom} H 0 Z`;
    const innerRect = `M ${margin.left},${margin.top} H ${margin.left + width} V ${margin.top + height} H ${margin.left} Z`;

    // Combine paths to create the frame with transparent center
    const framePath = `${outerRect} ${innerRect}`;

    // Append the frame path to the SVG
    svg.append('path')
        .classed('frame', true)
        .attr('d', framePath)
        .attr('fill',(isDarkMode === 0) ? 'rgba(255, 255, 255)' : 'rgba(0, 0, 0)')
        .attr('stroke', 'none')
        .style('opacity', 0)
        .attr('fill-rule', 'evenodd')
        .style('cursor', 'default')
        .style('pointer-events', 'none')


    // chart and animations
    // 'd' stands for duration | 't' for transition
    const dDelayStart = 2000;
    const dCirclesAdjust = 3000 ;
    const dWaitToPlaceWays = 500;

    const OneWayPlacementDuration = 1000;
    
    const dStartWayPlacement = dDelayStart + dCirclesAdjust + dWaitToPlaceWays

    const msInBetweenPlacements = 2 / speedPlacement

    const dMWayPlacement = (animationEnabled == 1) ? M_count * msInBetweenPlacements : 1000  // if animation is enabled both circles use the same time for fading, otherwise that will depend on the amount of paths to place
    const dFWayPlacement = (animationEnabled == 1) ? F_count * msInBetweenPlacements : 1000  // if animation is enabled both circles use the same time for fading, otherwise that will depend on the amount of paths to place
    const dWayPlacement = max([dMWayPlacement, dFWayPlacement])

    const dUntilPlacementEnd = dStartWayPlacement + dWayPlacement + OneWayPlacementDuration

    const tCirclesAdjust = transition()
        .duration(dCirclesAdjust)
        .ease(easeCubic)

    const tCirclesFade = transition()
        .ease( (animationEnabled == 1) ? easeLinear : easeCubicOut)    
    
    const tPlaceWays = transition()
        .ease(easeCubicOut)

    let sqrtScale = scaleSqrt()
        .domain([0, P_count])
        .range([0,  chartRadius])


    // ****************** CREATE AND ANIMATE KPIs ****************
    // circle charts
    const circlesData = [[fChart.x, fChart.y, F_count, cPathF, dFWayPlacement, fName], [mChart.x, mChart.y, M_count, cPathM, dMWayPlacement, mName]]

    const circles = svg.selectAll('circle.chart').data(circlesData)

    // circles start out as 50%
    circles.enter().append('circle')
        .classed('chart', true)
        .attr('cx', d => d[0])
        .attr('cy', d => d[1])
        .attr('r', d => sqrtScale(P_count/2))
        .attr('fill',  d => d[3])

    // circles grow to actual proportion
    svg.selectAll('circle.chart').transition(tCirclesAdjust).delay(dDelayStart)
        .attr('r', d => sqrtScale(d[2]))

    // move circles to zero while ways are placed
    svg.selectAll('circle.chart').transition(tCirclesFade).duration(d => d[4]).delay(dStartWayPlacement)
        .attr('r', d => sqrtScale(0))

    const percFormat = format('.0%')
    const percFormatDec = format('.1%')

    const circlesText = svg.selectAll('text.chart').data(circlesData)

    // circle charts label
    circlesText.enter().append('text')
        .classed('chart', true)
        .classed('kpi', true)
        .attr('gender', d => d[5])
        .text(percFormat(0.5))
        .attr('x', d => d[0])
        .attr('y', d => d[1] - sqrtScale(P_count/2) - 8)
        .attr('text-anchor', 'middle')
        .style('font-size', `${chartLabelSize}pt`)
        .style('cursor', 'default')
       
    svg.selectAll('text.chart').transition(tCirclesAdjust).delay(dDelayStart)
        .tween("text", function(d) {
            var element = select(this);
            var i = interpolate(0.5, d[2]/P_count); // tween with interpolate to transition text
            return function(t) {
                element.text(percFormat( i(t) ));
            };
        })
        .attr('y', d => d[1] - sqrtScale(d[2]) - 8)

    // text moves down while circles get emptier while ways are placed
    svg.selectAll('text.chart').transition(tCirclesFade).duration(d => d[4]).delay(dStartWayPlacement)
        .attr('y', d => d[1] - 8)

    // text grows to final KPI
    svg.selectAll('text.chart')
        .transition().duration(1800).ease(easeCubicOut).delay(dUntilPlacementEnd)
        .style('font-size', `${kpiTextSize}pt`)
        .attr('y', d => d[1])
        .style('cursor', 'pointer')

    const circlesTextUnderline = svg.selectAll('line.chart').data(circlesData)

    // kpi underline starts with no width
    circlesTextUnderline.enter().append('line')
        .classed('kpi', true)
        .attr('gender', d => d[5])
        .attr('x1', d => d[0])
        .attr('x2', d => d[0])
        .attr('y1', d => (device == 'mobile') ? d[1] + 10 :  d[1] + 16 )
        .attr('y2', d => (device == 'mobile') ? d[1] + 10 :  d[1] + 16 )
        .style('opacity', 1)
        .attr('stroke', d => d[3])
        .attr('stroke-width', '4px')

    // kpi underline transitions to width
    .transition().duration(1800).ease(easeCubicOut).delay(dUntilPlacementEnd)
        .style('opacity', 1)
        .attr('x1', d => d[0] - kpiUnderlineSize/2)
        .attr('x2', d => d[0] + kpiUnderlineSize/2)

    const circlesTextLabel = svg.selectAll('line.chart').data(circlesData)

    // kpi label is position differently depending on device type
    circlesTextLabel.enter().append('text')
        .classed('kpi', true)
        .attr('gender', d => d[5])
        .text(d => d[5])
        .attr('x', d => d[0])
        .attr('y', d => (device=='mobile') ? d[1] - kpiTextSize - 10 : d[1] + 24) // if mobile we place it above the kpi, otherwise below
        .style('opacity', 0)
        .attr('alignment-baseline', (device=='mobile') ? 'baseline' :'hanging')
        .attr('font-size', (device=='mobile') ? '8pt' :'11pt')
        .attr('text-anchor', 'middle')
        .style('fill', '#929292')

    // kpi label revealed
    .transition().ease(easeCubicOut).delay(dUntilPlacementEnd)
        .style('opacity', 1)

    

    // ****************** CREATE AND ANIMATE PATHS ****************

    if (animationEnabled == 1 ) {

        const initialPaths = map.selectAll('path.way').data(data)

        // append gray streets
        initialPaths.enter()
            .append('path')
                .classed('way', true)
                .classed('pre-colored', true)
                .attr('id', d=> d.id)
                .attr('d', d => transformPathData(d.path_data))
                .attr('stroke', cPathO)
                .attr('fill', 'none')
            // highlights
            .on("mouseenter", handleMouseEnter)
            .on("mouseout", handleMouseOut)
            // tooltips
            .on("mouseover", mouseover)
            .on("mousemove", mousemove)
            .on("mouseleave", mouseleave)
            // context menu
            .on("contextmenu", openContextMenu);

        // colored streets
        // we first create the path for other names as those will be placed below the male/female. This will only be turned to visible after all placement is done
        const pathO = map.selectAll('path.map.pathO').data(O)

        pathO.enter().append('path')
            .classed('way', true)
            .classed('colored', true)
            .classed('pathO', true)
            .attr('d', d => transformPathData(d.path_data))
            .attr('stroke', cPathO)
            .attr('fill', 'none')
            .style('opacity', 0)

        // add colored paths women
        const pathF = map.selectAll('path.map.pathF').data(F)

        pathF.enter().append('path')
            .classed('way', true)
            .classed('colored', true)
            .classed('pathF', true)
            .attr('d', d => transformPathData(d.path_data))
            .attr('stroke', cPathF)
            .attr('fill', 'none')
            .style('opacity', 0)
            .attr('transform', (d, i)=> `translate( ${translatePathToStartingPoint(transformPathData(d.path_data), (fChart.x - compensationX) / (1 - scalingFactor), (fChart.y - compensationY) / (1 - scalingFactor)) })`) // origin in the edge of the circle reducing as circle reduces
            // .attr('transform', (d, i)=> `translate( ${translatePathToStartingPoint(transformPathData(d.path_data), fChart.x + ((device == 'desktop')? sqrtScale(F_count) - sqrtScale(i+1) : 0), fChart.y + ((device == 'mobile')? sqrtScale(F_count) - sqrtScale(i+1) : 0)) })`) // origin in the edge of the circle reducing as circle reduces


        svg.selectAll('path.pathF').transition(tPlaceWays).duration(OneWayPlacementDuration)
            .delay((d, i)=>{
                svg.select(`.pre-colored[id='${d.id}']`).transition().duration(0).attr('opacity',0).delay(dStartWayPlacement + OneWayPlacementDuration + (i * (msInBetweenPlacements))) // remove gray path once colored one is placed
                return dStartWayPlacement + (i * (msInBetweenPlacements)) // 2 ms distance between path start moving
            })
            .attr('d', d => transformPathData(d.path_data))
            .style('opacity', 1)
            .attr('transform',`translate( 0, 0)`)
            

        // add colored paths men
        const pathM = map.selectAll('path.map.pathM').data(M)

        pathM.enter().append('path')
            .classed('way', true)
            .classed('colored', true)
            .classed('pathM', true)
            .attr('d', d => transformPathData(d.path_data))
            .attr('stroke', cPathM)
            .attr('fill', 'none')
            .style('opacity', 0)
            /* functions below are prior to map scaling */
            // .attr('transform', (d, i) => `translate( ${translatePathToStartingPoint(transformPathData(d.path_data), mChart.x + ((device == 'desktop')? sqrtScale(M_count) - sqrtScale(i+1) : 0), mChart.y + ((device == 'mobile')? sqrtScale(M_count) - sqrtScale(i+1) : 0)) })`) // origin in the edge of the circle reducing as circle reduces
            // .attr('transform', d => `translate( ${translatePathToStartingPoint(transformPathData(d.path_data), mChart.x, mChart.y) })`) // origin in the center of the circle
            /* functions below are post map scaling logic */
            .attr('transform', (d, i) => `translate( ${translatePathToStartingPoint(transformPathData(d.path_data), (mChart.x - compensationX + ((device == 'desktop')? sqrtScale(M_count) - sqrtScale(i+1) : 0)) / (1 - scalingFactor), (mChart.y - compensationY + ((device == 'mobile')? sqrtScale(M_count) - sqrtScale(i+1) : 0)) / (1 - scalingFactor) ) })`) // origin in the edge of the circle reducing as circle reduces
            // .attr('transform', (d, i) => `translate( ${translatePathToStartingPoint(transformPathData(d.path_data), (mChart.x - compensationX) / (1-scalingFactor), (mChart.y - compensationY) / (1 - scalingFactor) ) })`) // origin in the center of the circle

        svg.selectAll('path.pathM').transition(tPlaceWays).duration(OneWayPlacementDuration)
            .delay((d, i)=>{
                svg.select(`.pre-colored[id='${d.id}']`).transition().duration(30).attr('opacity',0).delay(dStartWayPlacement + OneWayPlacementDuration + (i * (msInBetweenPlacements))) // remove gray path once colored one is placed
                return dStartWayPlacement + (i * (msInBetweenPlacements))  // 2 ms distance between path start moving
            })
            .attr('d', d => transformPathData(d.path_data))
            .style('opacity', 1)
            .attr('transform',`translate( 0, 0)`)


        // once it is over placing the paths, it remove the pre-colored ones, make the others visible instead
        sleep(dUntilPlacementEnd).then(() => {
            
            svg.selectAll('path.pathO')
                .style('opacity', 1)
                
            svg.selectAll('path.pre-colored').remove()
        })


    } else if (animationEnabled == 0) {

        // colored streets
        // we first create the path for other names as those will be placed below the male/female. This will only be turned to visible after all placement is done
        const pathO = map.selectAll('path.map.pathO').data(O)

        pathO.enter().append('path')
            .classed('way', true)
            .classed('colored', true)
            .classed('pathO', true)
            .attr('d', d => transformPathData(d.path_data))
            .attr('stroke', cPathO)
            .attr('fill', 'none')
            .style('opacity', 1)

        // add colored paths women
        const pathF = map.selectAll('path.map.pathF').data(F)

        pathF.enter().append('path')
            .classed('way', true)
            .classed('colored', true)
            .classed('pathF', true)
            .attr('d', d => transformPathData(d.path_data))
            .attr('stroke', cPathF)
            .attr('fill', 'none')
            .style('opacity', 1)
           
        // add colored paths men
        const pathM = map.selectAll('path.map.pathM').data(M)

        pathM.enter().append('path')
            .classed('way', true)
            .classed('colored', true)
            .classed('pathM', true)
            .attr('d', d => transformPathData(d.path_data))
            .attr('stroke', cPathM)
            .attr('fill', 'none')
            .style('opacity', 1)
            
    }
    
    
    const contextMenu = select("#context-menu");

    select("body").on("click", function() {
        contextMenu.style("display", "none");
    });

    select("#menu-item-1").on("click", function(d) {
        showPopup(paramForm)
        contextMenu.style("display", "none");
    });

    svg.selectAll('path.colored')
    // highlight
        .on("mouseenter", handleMouseEnter)
        .on("mouseout", handleMouseOut)
    // tooltips
        .on("mouseover", mouseover)
        .on("mousemove", mousemove)
        .on("mouseleave", mouseleave)
    // context menu
        .on("contextmenu", openContextMenu);

    // make frame visible and add highlight action to kpis
    sleep(dUntilPlacementEnd).then(() => {
        svg.select('.frame').transition().duration(2000).ease(easeCubic)
            .style('opacity', 0.8)
            .style('pointer-events', 'auto')

        svg.selectAll('.kpi')    
        // highlight
            .on("mouseenter", highlightGender)
            .on("mouseout", unHighlightGender)
        // tooltips
            .on('mouseover', mouseoverKPI)
            .on('click', (device == 'desktop')? mouseclickKPI : '') // clicking to remove tooltip only active on desktop as clicking is already used to show tooltip in mobile
            .on("mousemove", mousemoveKPI)
            .on("mouseleave", mouseleaveKPI)
        
    })

    // *********** footer
    const footer = svg.append('foreignObject');
    footer
        .attr('x', 30)
        .attr('y', margin.top + height)
        .attr("width", width + margin.right)
        .attr("height", margin.bottom )
    .append("xhtml:div") // Use xhtml namespace
        .classed('footer', true)
        .html((language === 'pt') ? 
            `<span>Criado por <a href="https://www.linkedin.com/in/caiocaminoski/" target="_blank">@caiocaminoski</a> <a href="mailto:igualdade.nas.ruas@gmail.com">✉</a> inspirado em <a href="https://observablehq.com/@karimdouieb/brussels-streets-gender-inequality" target="_blank">karim_douieb</a>. ${textFooterCorrectStPT}</span>`
            :'<span>Created by <a href="https://www.linkedin.com/in/caiocaminoski/" target="_blank">@caiocaminoski</a> <a href="mailto:igualdade.nas.ruas@gmail.com">✉</a> inspired by the work of <a href="https://observablehq.com/@karimdouieb/brussels-streets-gender-inequality" target="_blank">karim_douieb</a>.</span>')  
        .style('opacity', 1)


    // *********** control zoom
    window.zoom = zoom()
        .scaleExtent([1 - scalingFactor, 50])
        .on('zoom', handleZoom);

    function initZoom() {      
        const transform = zoomIdentity.translate(compensationX, compensationY).scale(1 - scalingFactor); // scaling factor helps adjusting paths within a decent distance between each other. This zooms out to show all area from beggining. Compensation is added to X adn Y to better position map after zoom

        select('svg')
            .call(window.zoom).call(window.zoom.transform, transform);
    }

    function handleZoom(e) {
        select('g.map')
            .attr('transform', e.transform);
    }

    initZoom();
    hideLoader()
}

// Function to transform path data to a new starting coordinate
function translatePathToStartingPoint(pathData, newX, newY) {
    try{
        // Parse the path data to find the starting coordinate
        const match = pathData.match(/([ML])\s*([-\d.]+),([-\d.]+)/);
        if (!match) {
            throw new Error('Invalid path data');
        }
        
        // Current starting coordinates
        const startX = parseFloat(match[2]);
        const startY = parseFloat(match[3]);
        
        // Calculate the translation offsets
        const dx = newX - startX;
        const dy = newY - startY;
        
        return `${dx}, ${dy}`;
    } catch (error) {
        console.error('Error fetching or parsing the CSV file:', error);
        console.log('path error:', pathData)
        hideLoader()
}
}

const sleep = (milliseconds) => {
    return new Promise(resolve => setTimeout(resolve, milliseconds))
    }

function getCity() {
        const queryString = window.location.search;
        const urlParams = new URLSearchParams(queryString)
        return urlParams.get('city')
    }


async function importResources(varPath, dataPath) {
    await loadVariables(varPath)
    const data = loadData(dataPath)
    return data;
}

function detectDarkMode() {
    const bodyStyles = window.getComputedStyle(document.body);
    const backgroundColor = bodyStyles.backgroundColor;

    
    // Check if the background color is likely dark
    const isDarkBackground = backgroundColor === 'rgb(0, 0, 0)' || backgroundColor === 'black';

    if (isDarkBackground ) {
        var isDarkMode = 1
    } else {
        var isDarkMode = 0
    }

    return isDarkMode
}



window.MyGlobalFunctions = {
    hidePopup: function() {
        document.getElementById('hideForm').style.display = 'none';
        document.getElementById('popupContainer').style.display = 'none';
        document.getElementById('popupOverlay').style.display = 'none';
    }
}

function showPopup(paramForm) {
    const iframe = document.getElementById('popupIframe');
    const src = paramForm;
    iframe.src = src;
    
    document.getElementById('hideForm').style.display = 'block';
    document.getElementById('popupContainer').style.display = 'block';
    document.getElementById('popupOverlay').style.display = 'block';
}

function hideLoader() {
    const loaderOverlay = document.getElementById('loader-overlay');
    const content = document.getElementById('container');

    loaderOverlay.style.opacity = '0';
    loaderOverlay.style.visibility = 'hidden';

    setTimeout(() => {
        loaderOverlay.style.display = 'none';
        select("#container").classed("hidden", false);
    }, 200); // Match this duration with the CSS transition duration
}

function setLanguage(language) {

    // Update the document title based on the selected language
    if (language === 'pt') {
        document.title = "Igualdade nas ruas";
    } else {
        document.title = "Street gender equality";
        language = 'en'; // if language is not portuguese it falls back to english
    }

    // Hide all lang-container
    document.querySelectorAll('.lang-container').forEach(div => {
        div.classList.remove('active');
    });

    // Show the selected language lang-container
    document.getElementById(language).classList.add('active');

    return language
}

function getUrlLang() {
        const queryString = window.location.search;
        const urlParams = new URLSearchParams(queryString)
        return urlParams.get('lang')
    }


var language;

const urlLang = getUrlLang();
const userLang = navigator.language || navigator.userLanguage; 

// if language is set as pt in url or language browser is pt, it sets global language as pt, otherwise it falls back to en
if (urlLang === 'pt' || userLang.startsWith("pt")) {
    language = setLanguage('pt');
} else {
    language = setLanguage('en');
}

importResources(`config/${city}.js`, `data/${city}.csv`).then((data) => {createViz(data)});


</script>
</html>
