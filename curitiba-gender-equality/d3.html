<!DOCTYPE html>
<html>
<head>
    <title>Curitiba</title>
</head>
<body>
    <!-- <button onclick="resetZoom()">Reset zoom</button>
    <button onclick="center()">Center</button> -->
    <h1>Igualdade de gÃªnero nas ruas de Curitiba</h1>
    <h3>Ruas que levam nomes de <span class="women">mulheres</span> vs <span class="men">homens</span></h3>
    <div id="container"></div>
    
</body>
<style>

    body {
        margin: 0 0 0 0;
        /* background: rgb(248,248,248); */
        background: white;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        /* font-family: sans-serif; */
        color: rgb(43, 43, 43);
        margin-left: 30px;
    }

    h1 {
        margin-top: 12px; 
        margin-bottom: 12px;
    }

    h3 { 
        margin: 0 0 0 0;
        margin-bottom: 12px;
        /* margin-top: 65px;
        margin: 65px 0 0 0; */
     }

    svg {
        margin: 0 0 0 0;
        background: white;
    }

    path {
            transition: stroke 0.3s;
            cursor: pointer;
        }

    .overlay {
        opacity: 0;
        /* transition: opacity 0.8s ease-in-out; */
    }

    .men {
        color: #27A8D8
    }

    .women {
        color: #D85727
    }

    .footer {
        overflow: visible;
        white-space: nowrap;
        color: #00000080
    }


    /* .pathM{
        stroke: rgb(81, 169, 199)
    }

    .pathF{
        stroke: rgb(255, 153, 0)
    }

    .pathO{
        stroke: gray
    } */

</style>
<script type="module">
import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm"

console.log(window.innerHeight)

var margin = {top:0, right: 0, bottom: 20, left: 350},
    // width = 960 - margin.left - margin.right,
    // height = 830 - margin.top - margin.bottom;
    width = window.innerWidth - margin.left - margin.right - 30,
    height = window.innerHeight - margin.top - margin.bottom - (25 + 43 + 12 + 12 + 12 + 10);

var fChart = {x: margin.left/2, y: 200};
var mChart = {x: margin.left/2, y: 500};


// https://www.canva.com/colors/color-wheel/
// var cPathM = '#2BD4C9',
//     cPathF = '#D42B36',
//     cPathO = 'gray';

var cPathM = '#27A8D8',
    cPathF = '#D85727',
    cPathO = 'gray';

// var cPathM = '#00B1FF',
//     cPathF = '#FF4E00',
//     cPathO = 'gray';

// var cPathM = '#3AC5A3',
//     cPathF = '#C53A5C',
//     cPathO = 'gray';

(async () => {
  const csvUrl = 'https://raw.githubusercontent.com/caiocaminoski/caiocaminoski.github.io/main/curitiba-gender-equality/curitiba.csv';
  
  try {
    const response = await fetch(csvUrl);
    if (!response.ok) {
      throw new Error(`Network response was not ok: ${response.statusText}`);
    }
    const csvText = await response.text();

    // Parse CSV data using d3-dsv
    const data_input = d3.csvParse(csvText);

    const data = data_input.map((d, i)=>{
        return {
            id: i,
            name: d.name,
            path_data: d.path_data,
            gender: d.gender
        }
    })
    // const data_clean = data.filter(function(d){ return d.path_data != "" })
    
    // Example: Pass data to a function for further processing
    processData(data);

  } catch (error) {
    console.error('Error fetching or parsing the CSV file:', error);
  }
})();

function processData(data) {

    const M = data.filter(function(d){ return d.gender == "M" })
    const F = data.filter(function(d){ return d.gender == "F" })
    const O = data.filter(function(d){ return d.gender != "F"  && d.gender != "M"})

    const M_count = Object.keys(M).length
    const F_count = Object.keys(F).length
    const P_count = M_count + F_count
    const O_count = Object.keys(O).length
    
    console.log('M', M_count)
    console.log('F', F_count)
    console.log('F+M', P_count)
    console.log('F', O_count)

    console.log('F total %', F_count / (P_count + O_count))



    const svg = d3.select('#container').append('svg')
        .attr('height', height + margin.top + margin.bottom)
        .attr('width', width + margin.left + margin.right)




    const minLat = -25.6489423
    const maxLat = -25.343117
    const minLon = -49.3926966
    const maxLon = -49.1832167

    const lonRange = maxLon - minLon;
    const latRange = maxLat - minLat;
    
    // Calculate aspect ratio
    const aspectRatio = width / height;

    // Calculate the map's aspect ratio
    const mapAspectRatio = lonRange / latRange;

    let scaleX, scaleY;

    if (mapAspectRatio > aspectRatio) {
        // The map is wider than the container
        scaleX = d3.scaleLinear()
        .domain([minLon, maxLon])
        .range([margin.left, margin.left + width]);

        const adjustedHeight = width / mapAspectRatio;
        const offsetY = (height - adjustedHeight) / 2;

        scaleY = d3.scaleLinear()
        .domain([minLat, maxLat])
        .range([margin.top + adjustedHeight + offsetY, margin.top + offsetY]);
    } else {


        const adjustedWidth = height * mapAspectRatio;
        const offsetXTotal = (width - adjustedWidth);

        var offsetXLeft = offsetXTotal / 2;
        var offsetXRight = offsetXTotal / 2;

        // console.log('offsetXLeft', offsetXLeft)
        // console.log('offsetXRight', offsetXRight)

        // if ( offsetXLeft > margin.left ) {
        //     offsetXLeft = margin.left
        //     offsetXRight = offsetXTotal - margin.left
        // }

        // console.log('offsetXLeft', offsetXLeft)
        // console.log('offsetXRight', offsetXRight)
        console.log('adjustedWidth', adjustedWidth)

        // The map is taller than the container
        scaleY = d3.scaleLinear()
        .domain([minLat, maxLat])
        .range([margin.top + height, margin.top]);

        scaleX = d3.scaleLinear()
        .domain([minLon, maxLon])
        .range([margin.left, margin.left + adjustedWidth]);
        // .range([margin.left + offsetXLeft, margin.left + adjustedWidth + offsetXRight]);
    }

    // Function to transform path data
    function transformPathData(pathData) {
        return pathData.replace(/([ML])\s*([-\d.]+),([-\d.]+)/g, function(match, command, lon, lat) {
            const transformedLon = scaleX(+lon)
            const transformedLat = scaleY(+lat)
            return `${command} ${transformedLon},${transformedLat}`
        });
    }


    function handleMouseEnter() {
        const overlay = svg.select('.overlay');

        // Move the overlay to the end of the parent
        overlay.node().parentNode.appendChild(overlay.node());

        overlay.transition().duration(150).style('opacity', 1);

        // create copy of the hovered item on top of the overlay
        svg.select('.map').append('path')
            .attr('id', 'hovered')
            .attr('d', d3.select(this).attr('d'))
            .attr('stroke', d3.select(this).attr('stroke'))
            // .attr('stroke', 'red')
            .style('fill', 'none')
            .style('pointer-events', 'none')

    }

    function handleMouseOut() {
        const overlay = svg.select('.overlay');

        overlay.transition().duration(150).style('opacity', 0);

        // remove copy of the hovered item from the top of the overlay
        svg.select('#hovered').remove()
        
    }

    const paths = svg.append('g').classed('map', true).selectAll('path.way').data(data)



    paths.enter().append('path')
        .classed('way', true)
        .classed('pre-colored', true)
        .attr('id', d=> d.id)
        .attr('d', d => transformPathData(d.path_data))
        .attr('stroke', cPathO)
        .attr('fill', 'none')
        .on("mouseenter", handleMouseEnter)
        .on("mouseout", handleMouseOut)
        .append('title')
        .text(d=> d.name)

        svg.select('.map').append('rect')
        .classed('overlay', true)
        .attr('x', margin.left)
        .attr('y', margin.top)
        .attr('height', height)
        .attr('width', width)
        .attr('fill','rgba(255, 255, 255, 0.6)')
        .style('pointer-events', 'none')





    let zoom = d3.zoom()
        .scaleExtent([1, 10])
        .on('zoom', handleZoom);


    function initZoom() {
        // d3.select('g.map')
        d3.select('svg')
            .call(zoom);
    }


    function handleZoom(e) {
        d3.select('g.map')
            .attr('transform', e.transform);
    }

    function resetZoom() {
    	d3.select('g.map')
    		.transition()
    		.call(zoom.scaleTo, 1);
    }

    function center() {
    	d3.select('g.map')
    		.transition()
    		.call(zoom.translateTo, 0.5 * width, 0.5 * height);
    }

    initZoom();
    // updateData();
    // update();

    // define frame for map
    // Define outer and inner rectangles for the frame path
    const outerRect = `M 0,0 H ${width + margin.left + margin.right} V ${height + margin.top + margin.bottom} H 0 Z`;
    const innerRect = `M ${margin.left},${margin.top} H ${margin.left + width} V ${margin.top + height} H ${margin.left} Z`;

    // Combine paths to create the frame with transparent center
    const framePath = `${outerRect} ${innerRect}`;

    // Append the frame path to the SVG
    svg.append('path')
        .classed('frame', true)
        .attr('d', framePath)
        // .attr('fill', 'rgb(248,248,248)')
        .attr('fill', 'white')
        .attr('stroke', 'none')
        .style('opacity', 0)
        // .attr('stroke-width', 1)
        .attr('fill-rule', 'evenodd')
        // .attr('pointer-events', 'none');
        .style('cursor', 'default')


    // 'd' stands for duration | 't' for transition
    const dDelayStart = 2000// 2000;
    const dCirclesAdjust = 3000 //3000;
    const dWaitToPlaceWays = 500//1000;

    const OneWayPlacementDuration = 1000//3500
    
    const dStartWayPlacement = dDelayStart + dCirclesAdjust + dWaitToPlaceWays

    const dMWayPlacement = M_count * 2
    const dFWayPlacement = F_count * 2
    const dWayPlacement = d3.max([dMWayPlacement, dFWayPlacement])

    const dUntilPlacementEnd = dStartWayPlacement + dWayPlacement + OneWayPlacementDuration

    console.log(dUntilPlacementEnd)
    // const tDuration = 5000;
    // const tDelay = 2000;



    const tCirclesAdjust = d3.transition()
        .duration(dCirclesAdjust)
        .ease(d3.easeCubic)

    const tCirclesFade = d3.transition()
        .ease(d3.easeLinear)    
    

    const tPlaceWays = d3.transition()
        // .duration(tDuration)
        .ease(d3.easeCubicOut)

    let sqrtScale = d3.scaleSqrt()
        // .domain([0, d3.max([M_count, F_count])])
        .domain([0, P_count])
        .range([0,  margin.left * 0.4])

    const circlesData = [[fChart.x, fChart.y, F_count, cPathF, dFWayPlacement], [mChart.x, mChart.y, M_count, cPathM, dMWayPlacement]]

    const circles = svg.selectAll('circle.chart').data(circlesData)

    circles.enter().append('circle')
        .classed('chart', true)
        .attr('cx', d => d[0])
        .attr('cy', d => d[1])
        .attr('r', d => sqrtScale(P_count/2)) // it starts at 50% so half count
        .attr('fill',  d => d[3])

    svg.selectAll('circle.chart').transition(tCirclesAdjust).delay(dDelayStart)
        .attr('r', d => sqrtScale(d[2]))

    svg.selectAll('circle.chart').transition(tCirclesFade).duration(d => d[4]).delay(dStartWayPlacement)
        .attr('r', d => sqrtScale(0))

    const percFormat = d3.format('.0%')

    const circlesText = svg.selectAll('text.chart').data(circlesData)

    circlesText.enter().append('text')
        .classed('chart', true)
        .text(percFormat(0.5))
        .attr('x', d => d[0])
        .attr('y', d => d[1] - sqrtScale(P_count/2) - 8)
        .attr('text-anchor', 'middle')
        // .style('font-family', 'sans-serif')
        .style('font-size', '20pt')
        .style('cursor', 'default')

    svg.selectAll('text.chart').transition(tCirclesAdjust).delay(dDelayStart)
        .tween("text", function(d) {
            var element = d3.select(this);
            var i = d3.interpolate(0.5, d[2]/P_count);
            return function(t) {
                element.text(percFormat( i(t) ));
            };
            //return t => element.text(format(i(t)));
        })
        // .text(d=>percFormat(d[1]/P_count))
        .attr('y', d => d[1] - sqrtScale(d[2]) - 8)

    svg.selectAll('text.chart').transition(tCirclesFade).duration(d => d[4]).delay(dStartWayPlacement)
        .attr('y', d => d[1] - 8)

    svg.selectAll('text.chart')
        .transition().duration(1800).ease(d3.easeCubicOut).delay(dUntilPlacementEnd)
        .style('font-size', '42pt')

    const circlesTextUnderline = svg.selectAll('line.chart').data(circlesData)

    circlesTextUnderline.enter().append('line')
        .attr('x1', d => d[0])
        .attr('x2', d => d[0])
        // .attr('y1', d => d[1] + 20)
        // .attr('y2', d => d[1] + 20)
        .attr('y1', d => d[1] + 12)
        .attr('y2', d => d[1] + 12)
        .style('opacity', 1)
        .attr('stroke', d => d[3])
        .attr('stroke-width', '4px')

    .transition().duration(1800).ease(d3.easeCubicOut).delay(dUntilPlacementEnd)
        .style('opacity', 1)
        .attr('x1', d => d[0] - 40)
        .attr('x2', d => d[0] + 40)



    const footer = svg.append('foreignObject');
    footer.classed('footer', true)
        // .attr('pointer-events', 'none')
        .attr('x', 30)
        .attr('y', margin.top + height)
        .attr("width", 200)
        .attr("height", margin.bottom )
        
        .append("xhtml:div") // Use xhtml namespace
        .html('<span>VisualizaÃ§Ã£o criada por <a href="https://www.linkedin.com/in/caiocaminoski/" target="_blank">@caiocaminoski</a> inspirada no trabalho de <a href="https://observablehq.com/@karimdouieb/brussels-streets-gender-inequality" target="_blank">karim_douieb</a> e <a href="https://openknowledge.be/2020/03/03/equalstreetnames-brussels-launch-of-open-data-visualisation" target="_blank">EqualStreetNames</a></span>') 

        // .style("left", 30)
        // .style("top", margin.top + height + margin.bottom / 2)
        
        .style('opacity', 1)
        // .style('font-size', '20pt')
    .transition().duration(1800).ease(d3.easeCubicOut).delay(dUntilPlacementEnd)
        .style('opacity', 1)
        // .attr('stroke','rgb(48,48,48)')

    // footer.append("svg:a").attr("xlink:href", 'https://www.linkedin.com/in/caiocaminoski/')
    //     .append("svg:text")
    //     .text('@caio')
    //     .attr("dy", 0)
    //     .attr("dx", 0)
    //     .attr("text-anchor", "middle");




// circlesText.enter().append('text')
//         .classed('chart', true)
//         .text(percFormat(0.5))
//         .attr('x', d => d[0])
//         .attr('y', d => d[1] - sqrtScale(P_count/2) - 8)
//         .attr('text-anchor', 'middle')
//         .style('font-family', 'sans-serif')
//         .style('font-size', '20pt')

//     .transition(tCirclesAdjust).delay(dDelayStart)
//     .tween("text", function(d) {
//         var element = d3.select(this);
//         var i = d3.interpolate(0.5, d[2]/P_count);
//         return function(t) {
//             element.text(percFormat( i(t) ));
//         };
//     })
//     .attr('y', d => d[1] - sqrtScale(d[2]) - 8)


//     .transition(tCirclesFade).duration(d => d[4])
//         .attr('y', d => d[1] - 8)

//     .transition().duration(1000).ease(d3.easeCubicOut)
//         .style('font-size', '36pt')


    // svg.selectAll('text.chart').transition(tCirclesFade).duration(500).delay(dStartWayPlacement + dWayPlacement)
    //     .style('font-size', '36pt');

        

    // svg.selectAll('text.chart').transition().duration(80).ease(d3.easeCubicOut)
    //     .attr('text-decoration', 'underline')
        // .attr('text-decoration-color', 'red')//d => d[2])
        // .attr('text-decoration-thickness', '8pt')



    // we first create the path for other names as those will be placed below the male/female
    const pathO = svg.select('g').selectAll('path.map.pathO').data(O)

    pathO.enter().append('path')
        .classed('way', true)
        .classed('colored', true)
        .classed('pathO', true)
        .attr('d', d => transformPathData(d.path_data))
        .attr('stroke', cPathO)
        .attr('fill', 'none')
        .style('opacity', 0)


    const pathM = svg.select('g').selectAll('path.map.pathM').data(M)

    pathM.enter().append('path')
        .classed('way', true)
        .classed('colored', true)
        .classed('pathM', true)
        .attr('d', d => transformPathData(d.path_data))
        .attr('stroke', cPathM)
        .attr('fill', 'none')
        .style('opacity', 0)
        .attr('transform', (d, i) => `translate( ${translatePathToStartingPoint(transformPathData(d.path_data), mChart.x + sqrtScale(M_count) - sqrtScale(i+1) , mChart.y) })`)
        // .attr('transform', d => `translate( ${translatePathToStartingPoint(transformPathData(d.path_data), mChart.x, mChart.y) })`)


    svg.selectAll('path.pathM').transition(tPlaceWays).duration(OneWayPlacementDuration)
        .delay((d, i)=>{
            svg.select(`.pre-colored[id='${d.id}']`).transition().duration(30).attr('opacity',0).delay(dStartWayPlacement + OneWayPlacementDuration + (i * (2)))//.remove()
            return dStartWayPlacement + (i * (2))
        })
        .attr('d', d => transformPathData(d.path_data))
        .style('opacity', 1)
        .attr('transform',`translate( 0, 0)`)

    const pathF = svg.select('g').selectAll('path.map.pathF').data(F)

    pathF.enter().append('path')
        .classed('way', true)
        .classed('colored', true)
        .classed('pathF', true)
        .attr('d', d => transformPathData(d.path_data))
        .attr('stroke', cPathF)
        .attr('fill', 'none')
        .style('opacity', 0)
        .attr('transform', (d, i)=> `translate( ${translatePathToStartingPoint(transformPathData(d.path_data), fChart.x + sqrtScale(F_count) - sqrtScale(i+1), fChart.y) })`)


    svg.selectAll('path.pathF').transition(tPlaceWays).duration(OneWayPlacementDuration)//.delay((d, i)=>{return dStartWayPlacement + (i * (2))})//.delay((d, i)=>{return tDuration + tDelay + (i * (tDuration / data.lenght))})
        .delay((d, i)=>{
            svg.select(`.pre-colored[id='${d.id}']`).transition().duration(0).attr('opacity',0).delay(dStartWayPlacement + OneWayPlacementDuration + (i * (2)))//.remove()
            return dStartWayPlacement + (i * (2))
        })
        .attr('d', d => transformPathData(d.path_data))
        .style('opacity', 1)
        .attr('transform',`translate( 0, 0)`)
        
    
        
    svg.selectAll('path.colored')
        .on("mouseenter", handleMouseEnter)
        .on("mouseout", handleMouseOut)
    
    svg.selectAll('path.colored')
        .append('title')
        .text(d=> d.name)

    // svg.selectAll('path.pre-colored').transition(t).delay(tDelay + tDuration * 2)
    //     .attr('opacity',0)


    sleep(dUntilPlacementEnd).then(() => {
        
        svg.selectAll('path.pathO')//.transition().duration(80).ease(d3.easeCubic)
            .style('opacity', 1)
            
        svg.selectAll('path.pre-colored').remove()

        
        svg.select('.frame').transition().duration(2000).ease(d3.easeCubic)
            .style('opacity', 0.8)

            
    })


        // // Store original colors in a data attribute
        // document.querySelectorAll('.way').forEach(path => {
        //     path.dataset.originalColor = path.getAttribute('stroke');
        // });

        // // Add event listeners to handle hover and revert
        // document.querySelectorAll('.way').forEach(path => {
        //     path.addEventListener('mouseover', function() {
        //         // Change all paths to gray except the hovered path
        //         document.querySelectorAll('.way').forEach(otherPath => {
        //             if (otherPath !== this) {
        //                 otherPath.setAttribute('stroke', 'gray');
        //             }
        //         });
        //         // Change hovered path to red
        //         this.setAttribute('stroke', 'red');
        //     });

        //     path.addEventListener('mouseout', function() {
        //         // Restore original colors
        //         document.querySelectorAll('.way').forEach(otherPath => {
        //             otherPath.setAttribute('stroke', otherPath.dataset.originalColor);
        //         });
        //     });
        // });


}


// Function to transform path data to a new starting coordinate
function translateWholePathToStartingPoint(pathData, newX, newY) {
    // Parse the path data to find the starting coordinate
    const match = pathData.match(/([ML])\s*([-\d.]+),([-\d.]+)/);
    if (!match) {
        throw new Error('Invalid path data');
    }
    
    // Current starting coordinates
    const startX = parseFloat(match[2]);
    const startY = parseFloat(match[3]);
    
    // Calculate the translation offsets
    const dx = newX - startX;
    const dy = newY - startY;
    
    // Transform the path data by translating all coordinates
    return pathData.replace(/([ML])\s*([-\d.]+),([-\d.]+)/g, function(match, command, x, y) {
        const transformedX = parseFloat(x) + dx;
        const transformedY = parseFloat(y) + dy;
        return `${command} ${transformedX},${transformedY}`;
    });
}



// Function to transform path data to a new starting coordinate
function translatePathToStartingPoint(pathData, newX, newY) {
    try{
        // Parse the path data to find the starting coordinate
        const match = pathData.match(/([ML])\s*([-\d.]+),([-\d.]+)/);
        if (!match) {
            throw new Error('Invalid path data');
        }
        
        // Current starting coordinates
        const startX = parseFloat(match[2]);
        const startY = parseFloat(match[3]);
        
        // Calculate the translation offsets
        const dx = newX - startX;
        const dy = newY - startY;
        
        return `${dx}, ${dy}`;
    } catch (error) {
        console.error('Error fetching or parsing the CSV file:', error);
  }
}


const sleep = (milliseconds) => {
  return new Promise(resolve => setTimeout(resolve, milliseconds))
}

</script>
</html>
